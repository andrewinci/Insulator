task mergeLocalLibs(type: Jar) {
    group = 'distribution'
    if (!project.tasks.names.contains("dist")) {
        return
    }
    dependsOn 'dist'
    duplicatesStrategy(DuplicatesStrategy.WARN)

    def distPath = "${buildDir}/distributions/app/lib/"
    destinationDirectory = file(distPath)
    archiveFileName = "insulator.jar"
    def localLibs = ["app.jar", "configuration.jar", "helper.jar",
                     "jsonhelper.jar", "kafka.jar", "update.jar"]
            .collect { "${distPath}$it" }
    from {
        localLibs.collect { zipTree(it) }
    }
    with jar

    // delete unused files
    doLast {
        localLibs.forEach { file(it).delete() }
    }
}

task getDependencySources(type: DefaultTask) {
    group = "remoteUpdate"
    doLast {

        if (!buildDir.exists()) {
            buildDir.mkdir()
        }
        def outFile = file("${buildDir}/dependencies.txt")
        def dependencyMap = loadCache(outFile)

        Set dependencySet = []
        configurations.compileClasspath.resolvedConfiguration.firstLevelModuleDependencies.each { dep ->
            def addToJson
            addToJson = { resolvedDep ->
                dependencySet.add([
                        groupId   : resolvedDep.module.id.group,
                        artifactId: resolvedDep.module.id.name,
                        version   : resolvedDep.module.id.version
                ])

                if (resolvedDep.children.size() != 0) {
                    resolvedDep.children.each { childResolvedDep ->
                        if (resolvedDep in childResolvedDep.getParents() && childResolvedDep.getConfiguration() == 'compile') {
                            addToJson(childResolvedDep)
                        }
                    }
                }
            }
            addToJson(dep)
        }
        for (d in dependencySet) {
            def artifactName = "${d.artifactId}-${d.version}.jar"
            if (dependencyMap[artifactName] != null) {
                println("Using cached $artifactName")
                continue
            } else {
                println("Dependency $artifactName not cached, searching online")
            }
            def urlPart = "${d.groupId.replace('.', '/')}/${d.artifactId}/${d.version}/${artifactName}"
            for (repo in project.repositories) {
                try {
                    def url = "${repo.url}${urlPart}"
                    url.toURL().text
                    // url found, save it and break loop
                    dependencyMap[artifactName] = url
                    logger.debug("Artifact ${d.artifactName} available from ${repo.name} at ${url}")
                    break
                } catch (Exception ex) {
                    logger.debug("Unable to downaload ${d.artifactName} from repo ${repo.name} (${repo.url}): ${ex.localizedMessage}")
                }
                // url not found, store to avoid wasting time next time
                dependencyMap[artifactName] = "NOT-FOUND($urlPart)"
            }
        }
        outFile.delete()
        dependencyMap.each {
            outFile << "${it.key}\t${it.value}\n"
        }
    }
}

static def loadCache(File outFile) {
    // load cache
    def dependencyMap = [:]
    try {
        if (outFile.exists())
            outFile.text.split('\n').each {
                def dep = it.split('\t')
                dependencyMap[dep[0]] = dep[1]
            }
    } catch (Exception e) {
        outFile.delete()
    }
    return dependencyMap
}
